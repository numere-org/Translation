<!--
	NumeRe: Framework fuer Numerische Rechnungen
	Copyright (C) 2021  Erik Haenel et al.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<article id="window">
	<title string="Graphical user interfaces" />
	NumeRe is capable of generating and interacting with graphical user interfaces, which can be used to develop even sophisticated applications (or prototypes) with comparatively little effort. The central command for this is <code>window</code> in the form<codeblock>RES = window EX [-PAR]</codeblock>Whereby the return values <code>RES</code> of the command differ depending on the used expression <code>EX</code> and the parameters <code>PAR</code>. To create a new window, the form<codeblock>ID = window LAYOUTSCIPT</codeblock>can be used. It returns the ID of the new window created from the layout script (see later section). This ID can later be used to interact with this window and programmatically change properties (the parameters are described in more detail in the following section):<codeblock>ITEMIDS = window ID -getitems=TYPE\nVAL = window ID -get PROP\nLOG = window ID -set PROP=VAL\nLOG = window ID -close</codeblock>.
	<h>Parameters for this command</h>
	<list>
		<item node="set PROP=VAL">The <code>set</code> parameter is used to modify the properties <code>PROP</code> in an already open window. The properties <code>value</code>, <code>label</code>, <code>color</code> and <code>state</code> can be modified in the process. These will be defined in more detail in a later section. The return value of the command in this case is a logical <code>true</code> or <code>false</code>, which indexes whether the modification was successful</item>.
		<item node="get PROP">The <code>get</code> parameter is used to read the values of the properties <code>PROP</code> from an already open window. The properties <code>value</code>, <code>label</code>, <code>color</code> and <code>state</code> can be read.</item>.
		<item node="item=ID">This option allows a single element of the window to be selected, otherwise the properties of the window itself are used. <em>Note:</em> Some elements may not have all properties</item>.
		<item node="getitems=TYPE">This parameter can be used to read the ITEMIDS of all elements in a window that match a specific type <code>TYPE</code>. For <code>TYPE</code>, the layout script commands can be used (except <code>layout</code> and <code>group</code>).</item>.
		<item node="close">This parameter closes the corresponding window. The return value is a logical value that indexes success. <em>Note:</em> the <a href="nhlp://close?frame=new">command expression</a> <code>close -all</code> will also close all windows created with <code>window</code>.</item>
	</list>
	<h>Layout scripts</h>
	A central element in the creation of a graphical user interface are layout scripts. These are files which use the <em>*.nlyt</em> file extension. They are expected by default in the <code>&lt;scriptpath&gt;</code>, but can also be loaded from another folder by explicitly specifying the path.
	In a layout script, a <em>very restricted</em> NumeRe syntax can be used: Comments by <code>##</code> and <code>#* ... *#</code> are fully supported. Control flow elements such as <code>for ... endfor</code> and <code>if ... else ... endif</code> on the other hand are not supported. In addition, only code that is located in the first <code>layout ... endlayout</code> block of the file and only command expressions of the following list can be used. Expressions separate from this are not possible.
	A layout script is composed of the following command expressions:
	<list>
		<item node="layout [-PAR]<br> ...<br>endlayout">This block encloses all other GUI elements and defines the window itself. Parameters can be used to modify the background color (<code>color={R,G,B}</code>), window title (<code>title=TITLE</code>), window icon (<code>icon=PATH/TO/ICON.ico</code>) and window size (<code>size={x,y}</code>).</item>.
		<item node="group [-PAR]<br> ...<br>endgroup">These blocks can be used to group additional GUI elements (including additional <code>group ... endgroup</code> blocks) and to adjust the orientation of the element arrangement (<code>type=ORIENT</code>).<br>If an additional <code>label=NAME</code> is used, the group is embedded in an additional box, labeled accordingly.<br>If <code>style=tabs</code> is used together with <code>label=NAME</code>, the embedded GUI elements are displayed as part of a tab. All subsequent groups with <code>style=tabs label=TABLABEL</code> are automatically integrated as additional tabs. Tabs separate from this must be embedded in additional groups.<br>If <code>style=menu</code> is used together with <code>label=NAME</code>, the following GUI elements (a menu supports only <code>menuitem</code>, <code>separator</code> and <code>checkbox</code>) will be displayed as part of a menu. Embedded menu groups are realized as submenus and all following groups with <code>style=menu label=MENULABEL</code> are automatically realized as additional menus. However, there can be only one menu bar per window.<br>Groups also affect the scaling behavior of the individual GUI elements for this purpose and restrict this to their alignment. The <code>expand</code> option can be used to disable this behavior, so that scaling is done in <expr>x</expr> and <expr>y</expr> direction.</item>.
		<item node="button EX [-set PAR]">Creates a clickable button labeled with <code>EX</code>.</item>.
		<item node="radio EX [-set PAR]">Creates a radio group whose values are taken from <code>EX</code> in the form of a list of strings.</item>
		<item node="statictext EX [-set PAR]">Represents the text from <code>EX</code> without any other GUI elements.</item>.
		<item node="textfield EX [-set PAR]">Generates a text input line with the default value <code>EX</code>.</item>
		<item node="treelist [-set PAR]">Generates a treelist which can additionally be equipped with checkboxes. The number of columns and elements can be specified by <code>size={row, col}</code> or directly by specifying values using <code>label={LABEL1, ...}</code> and <code>value={VAL1, ...}</code>. <code>value={VAL1, ...}</code> specifies the elements row by row, where the columns must be separated by tabs (<code>\t</code>) (e.g.: <code>value={"COL1\tCOL2\tCOL3\t...", "...}</code>). If additional checkboxes are used, the first value (<code>1</code> or <code>0</code>) defines the status of these checkboxes (e.g.: <code>value={"1\tCOL1\t...", "0\t...}</code>).</item>
		<item node="checkbox EX [-set PAR]">Generates a clickable checkbox labeled with <code>EX</code>.</item>.
		<item node="dropdown EX [-set PAR]">Generates a dropdown list whose values are taken from <code>EX</code> in the form of a list of strings.</item>.
		<item node="spinbut [-set PAR]">Generates a spin button that can be labeled with <code>label=LABEL</code>. Minimum (<code>min=VAL</code>) and maximum (<code>max=VAL</code>) are configurable.</item>.
		<item node="slider [-set PAR]">Generates a slider. Minimum (<code>min=VAL</code>) and maximum (<code>max=VAL</code>) are configurable.</item>
		<item node="gauge [-set PAR]">Creates a progress bar that can be oriented either horizontally or vertically.</item>
		<item node="tablegrid [-set PAR]">Creates a table grid with a defined number of rows and columns (<code>size={row, col}</code>), but at least one row and one column. Values of the table can be modified by <code>window ID -set value=TABLEDATA() item=ITEMID</code> and read by <code>window ID -get value item=ITEMID target=TARGETTABLE()</code>. In the absence of the <code>target=TARGETTABLE()</code> option, <code>valtable()</code> is used as default.</item>.
		<item node="bitmap EX [-set PAR]">Displays the image from the <code>EX</code> file.</item>
		<item node="grapher [-set PAR]">Generates a graph object with configurable size (<code>size={x,y}</code>, by default <expr>640times480</expr>). The graph object can only be populated by a plotting command using the <code>streamto={WINID,ITEMID}</code> option.</item>.
		<item node="menuitem EX [-set PAR]">Defines an item in a menu labeled <code>EX</code>. <code>EX</code> may contain tab-delimited shortcuts which are registered automatically. The <code>type=checkmark</code> option embeds a checkbox in the menu item. The same can be achieved with <code>checkbox</code> when used as part of a menu.</item>.
		<item node="separator EX [-set PAR]">Inserts a separator object. This can be either a horizontal or vertical line (<code>type=horizontal</code> or <code>type=vertical</code> respectively) or a space of height and width EX (<code>type=space</code>).</item>.
		<item node="prop EX">Generates one or more new internal variables for the current window layout, which can be filled with information. The variables are intrinsically <em>typeless</em> and can contain numeric values as well as strings. To read or modify these variables, <code>window ID -get value prop=PROPNAME</code> or <code>window ID -set value=VALUE prop=PROPNAME</code> must be used.</item>.
	</list>
	Thus, a layout script has the following generic shape:
	<codeblock>
		layout [-PAR]
		\tGUI-ELEMENTS OR group ... endgroup
		endlayout
	</codeblock>
	<em>Note:</em> In case of embedding a window layout into a <a href="nhlp://package?frame=new">package</a> the target filename and path must be additionally specified between <code>layout</code> and its parameters, e.g. <code>layout "&lt;procpath&gt;/myapp/appmain.nlyt" -title="My App" ...</code> When using the package creator in the tools menu this will be inserted automatically.
	<em>Note:</em> For documentation purposes, the <code>\layout LAYOUTNAME</code> keyword can be used in documentation comments to create a corresponding heading in the <a href="nhlp://latex?frame=new">PDF</a>.
	<h>Property options for the commands in layout scripts</h>.
	The GUI elements in the upper list can be further modified by the following property options. However, not all commands support the same property options.
	<list>
		<item node="size={x,y}">Set the size of the window, the graph object, the text field (each in pixels), and the treelist and the table grid (each in rows and columns).</item>
		<item node="color={R,G,B}">Customize foreground (<code>button</code> and <code>statictext</code>) or background (all others except <code>grapher</code> and <code>tablegrid</code>) color of a GUI element. RGB values are to be specified per channel in the interval [0,255].</item>.
		<item node="id=ID">Set a self-defined ITEMID of a GUI element. The ITEMID range [0,999] is reserved for the user. GUI elements without this option have an ITEMID greater than or equal to 1000, and these ITEMIDs do not have to be consecutive.</item>.
		<item node="value=VAL">Defines the default value (when used in the layout script) or can be used to read or modify the current value of a GUI element. The <code>treelist</code> command can hold a list of values in the form of a vector in this case. <em>Note:</em> the value of the window itself is its size (when used in e.g. <code>window ID -get value</code> without <code>item=ITEMID</code>).</item>
		<item node="type=TYPE">Defines the orientation of the GUI element (<code>type=vertical</code> and <code>type=horizontal</code>) at <code>group ... endgroup</code>, <code>radio</code>, <code>separator</code> and <code>gauge</code>. Can also be used to make a <code>textfield</code> multiline via <code>type=multiline</code>, or to enable additional checkboxes via <code>type=checkmark</code> at <code>treelist</code> and <code>menuitem</code>. <code>type=space</code> defines that <code>separator</code> shall be realized as empty space.</item>.
		<item node="align=ALIGNMENTSTRING">This option defines the alignment of a GUI element in the space specified by its surrounding group. <em>Example:</em> for <expr>n</expr> elements in a group, each element has a defined portion (for <expr>n</expr> equal elements, this is <expr>1/n</expr>) of the available space. In this space, the <code>align=ALIGNMENTSTRING</code> option can be used to determine the positioning of the element in question.<br>The alignment string may be composed of up to two of the following five characters: <code>"LRTBC"</code> (Left, Right, Top, Bottom, Center). Default is <code>"LC"</code>.</item>.
		<item node="label=NAME">Many GUI elements can be additionally labeled with this option. For <code>button</code>, <code>value</code> and <code>label</code> are identical. For the <code>treelist</code> command, this option defines the names of the columns and can be passed multiple values in the form of a vector.</item>.
		<item node="state=STATE">This option can be used to programmatically enable (<code>state=enabled</code>), disable (<code>state=disabled</code>), and hide (<code>state=hidden</code>) GUI elements. Elements are enabled by default. Hidden elements will still need their space in the window.</item>
		<item node="onclick=EVENT">Defines the event handler to be used when clicking <code>button</code>, a cell in a <code>tablegrid</code>, an element in <code>treelist</code>, a menu entry, and an item in <code>grapher</code> (see below for details).</item>
		<item node="onchange=EVENT">Defines the event handler to use when changing a value in a GUI element (see below for details).</item>
		<item node="onopen=EVENT">Defines the event handler to use when opening the window (see below for details). This event handler <em>must</em> be appended to <code>layout</code>, must be a NumeRe procedure, and must <em>only</em> have <code>void</code> as a return value.</item>
	</list>
	<h>Menus</h>
	There can be only one menu bar per window, to which each new menu is automatically appended. Menus are created by integrating a group defined for this purpose into the layout script. In this, the entries are then defined via <code>menuitem</code>:
	<codeblock>
		[...]
		group -style=menu label=MENUNAME
		\tmenuitem MENUENTRY -set onclick=EVENT
		\tgroup -style=menu label=SUBMENUNAME
		\t\t[...]
		\tendgroup
		\tmenuitem MENUENTRY_CHECKBOX -set type=checkmark onclick=EVENT
		\t[...]
		endgroup
		[...]
	</codeblock>
	In addition to the <code>menuitem</code> command, <code>separator</code> (creates a horizontal separator) and <code>checkbox</code> (as an alias for <code>menuitem EX -set type=checkmark</code>) can be used. All other commands are ignored in a menu definition.
	Shortcuts (keyboard combinations) can be automatically assigned to menus by appending them to the menu item name after a tab: <code>NAME\tSHORTCUT</code>. Shortcuts can be composed of a modifier (<code>CTRL</code>, <code>ALT</code>, <code>SHIFT</code>) a plus or minus and a key or function key (<code>F1</code>-<code>F10</code>). Directional keys (<code>UP</code>, <code>LEFT</code>, etc.) and spaces (<code>SPACE</code>) are also supported here: <code>"Select all\tCTRL-A", "Start block\tCTRL-SHIFT-B", "New definition\tF8", "Move right\tSHIFT-RIGHT"</code>.
	<em>Note:</em> The command sequence <code>window ID -get value item=MENUID</code> returns only the name of the entry (or the state of the checkbox, if any) without any shortcut. The full entry is obtained via <code>window ID -get label item=MENUID</code>.
	<h>Events and event handling</h>.
	Unlike the simple <a href="nhlp://dialog?frame=new">dialogs</a> that can be generated with <code>dialog</code>, which wait for a user interaction before allowing new input to the NumeRe console, the graphical user interfaces generated by <code>window</code> are event-based. This means that the console can still be used even if a window is open. As soon as the user interacts with it, it generates events that can be processed.
	To do this, event handlers can be assigned to GUI elements via the <code>onclick=EVENT</code> and <code>onchange=EVENT</code> options. These are called as soon as the corresponding event occurs and can process the event. The simplest event handler is <code>evt_close()</code>, which simply closes the window, for example in this form:<codeblock>button "End" -set onclick=evt_close()</codeblock>Additional event handlers are these functions:
	<list>
		<item node="evt_copyvalues(nFromId,nToId1,...)">Copies the values of <code>nFromId</code> into the elements with IDs <code>nToId1, ...</code></item>.
		<item node="evt_changestate(nId,sState)">Changes the state of the <code>nId</code> element to the new <code>sState</code></item> state.
		<item node="evt_sendvaltoitem(nToId1,...)">Copies the values of the event-triggering element into the elements with IDs <code>nToId1, ...</code></item>.
	</list>
	<em>Note:</em> GUI event handlers can only be used directly in a layout script and the arguments must be literals (i.e. not variables) (<code>onchange=evt_sendvaltoitem(5, 7)</code> or <code>onclick=evt_changestate(1, "hidden")</code>).
	The alternative is to use <a href="nhlp://procedure?frame=new">NumeRe procedures</a>. These must have the following signature<codeblock>procedure $PROC(WINID, ITEMID, EVENT{}) :: event</codeblock>where <code>WINID</code> is the ID of the window, <code>ITEMID</code> is the ID of the GUI element, and <code>EVENT{}</code> is a key-value list (the <code>getkeyval()</code> function simplifies the interaction) containing the following information: <codeblock>EVENT{} = {"event", "EVENTTYPE", "object", "TYPE", "value", VALUE, "state", "STATE"}</codeblock>A procedure can be used as an event handler for <em>any</em> events and also for completely different windows (if that makes sense in the current context).
	In the previous example with <code>button "End" -set onclick=$PROC()</code> (argument list is unnecessary), the following values would be included:<codeblock>EVENT{} = {"event", "onclick", "object", "button", "value", "End", "state", "enabled"}</codeblock>.
	<em>Note:</em> If an event handler has a longer computation time, it will not negatively affect the graphical user interface. It is still usable. However, it should be noted that the user naturally expects a response in a reasonable time frame; at least once the information that computation is in progress.
	<h>Internal variables</h>.
	In addition to the displayed GUI elements, it is often necessary to assign internal variables to a window in order to be able to uniquely assign further information to that window. <code>prop</code> can be used for this purpose: <code>prop VAR1 = VAL1, VAR2, ...</code> This command generates one or more internal variables which have no specific type, i.e. they can contain both a numeric value or a string.
	Internal variables can be read with the command sequence <code>window ID -get value prop=VARNAME</code> and written with <code>window ID -set value=VAL prop=VARNAME</code>.
	<example desc="A window layout, which will display an interactive preview of the result of <code>smooth</code> with a custom selectable level:" type="verbatim">
		|   ## Window layout: A wide grapher object at the top, a row of controls below
		|   layout -title="Smooth Preview" size={700, 300}
		|       grapher -set id=0 size={600, 200}
		|       group -type=horizontal
		|           textfield #&lt;loadpath&gt; -set id=1
		|           button "Select" -set onclick=$smoothevent()
		|           spinbut -set min=1 max=10 value=3 label="Smoothing level" id=2
		|           button "Smooth!" -set onclick=$smoothevent()
		|       endgroup
		|   endlayout
		|
		|
		|   ## Procedure, which would be found at '&PROCPATH&/smoothevent.nprc'
		|   procedure $smoothevent(_nWinID, _nItemID, _event{}) :: event
		|       str sPath
		|       tab dat()
		|       var nOrder = 1
		|       
		|       sPath = window _nWinID -get value item=1;
		|       clear data() -ignore
		|       
		|       if (getkeyval(_event{}, "value") == "Select")
		|           ## Select a new file using a dialog and plot its contents
		|           sPath = dialog sPath -set type=filedialog title="Select file";
		|           window _nWinID -set value=sPath item=1;
		|           load sPath;
		|           plot data(:, 1:2) "" -set box streamto={_nWinID, 0} reset aspect=3 connect
		|       else
		|           ## Smooth the available file and plot it together with the original data
		|           nOrder = window _nWinID -get value item=2;
		|           load sPath;
		|           copy data(:, 1:2) -target=dat();
		|           smooth dat(:, 2) -order=nOrder
		|           plot data(:, 1:2) "", dat() "" -set box streamto={_nWinID, 0} reset aspect=3 connect
		|       endif
		|       
		|       return void;
		|   endprocedure
	</example>
	<img src="<>/docs/window.png" />
	<em>See also:</em> <a href="nhlp://plot?frame=self">help plot</a>, <a href="nhlp://dialog?frame=self">help dialog</a> and <a href="nhlp://procedure?frame=self">help procedure</a>
</article>