<!--
	NumeRe: Framework fuer Numerische Rechnungen
	Copyright (C) 2016  Erik Haenel et al.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<article id="cache">
	<title string="Tabellen (Caches)" idxkey="cache, table"/>
	<keywords>
		<keyword>cache</keyword>
		<keyword>table</keyword>
		<keyword>tabell</keyword>
		<keyword>rename</keyword>
		<keyword>swap</keyword>
		<keyword>desc</keyword>
		<keyword>lines</keyword>
		<keyword>nlines</keyword>
		<keyword>cols</keyword>
		<keyword>ncols</keyword>
		<keyword>every</keyword>
	</keywords>
	<contents>
		Tabellen sind aktive Speicher in NumeRe, die tabellare Daten zwischenspeichern können, damit selbige weiterverarbeitet werden können. Tabellarische Daten zeichnen sich dadurch aus, dass die Daten spaltenweise organisiert sind. Spalten in NumeRe-Tabellen können entweder numerische Werte oder <a href="nhlp://string?frame=new">Zeichenketten</a> enthalten. Werden numerische Werte in Zeichenketten-Spalten geschrieben, werden sie automatisch in Zeichenketten konvertiert. Schreiben von Zeichenketten in numerische Spalten ist dagegen <em>nicht</em> möglich.
		Standardmäßig existiert die Tabelle <code>table()</code>. Mit dem Kommando <code>new</code> können aber weitere Tabellen mit anderen Namen erzeugt werden:<codeblock>new TABLE1(), TABLE2(), ...</codeblock>
		Einzelne Elemente einer Tabelle können mit der Syntax <code>TABLE(ZEILE, SPALTE)</code> ausgelesen werden. Ebenso können damit auch Werte in die Tabelle geschrieben werden. Dabei sind Tabellen wie gewöhnliche Variablen zu behandeln. Die Indizierung erfolgt dabei durch natürliche Zahlen <em>größer</em> Null: 1,2,3,...
		Bereiche von Elementen können dabei mit der Syntax <code>ERSTER INDEX:ZWEITER INDEX</code> erhalten werden. Wird dabei einer der beiden Indices weggelassen, wird er automatisch durch den minimalen bzw. maximalen Index ergänzt. Fehlen beide Indices, wird folglich der gesamte, mögliche Bereich ausgewählt. Es können auch Zeilen/Spalten aus anderen Tabellen oder Datenfiles als Indexmenge verwendet werden.
		Wird eine gesamte Spalte in der Form <code>TABLE(:,j) = VALUES</code> überschrieben, so kann dabei auch der Typ der Spalte <code>j</code> von numerisch zu Zeichenkette oder umgekehrt geändert werden. Die Spaltenüberschrift bleibt dabei erhalten; eventuell vorher in der Spalten <code>j</code> enthaltene Daten werden <em>komplett</em> entfernt.
		Beim Zugriff auf eine Tabelle enthalten die speziellen Variablen <code>nlines</code> die Zahl der Zeilen und <code>ncols</code> die Zahl der Spalten der aktuellen Tabelle, wenn sie in dessen Argumentklammern verwendet werden. Das gilt auch, wenn weitere Datenobjekte im Ausdruck oder als Indexmenge verwendet werden:<codeblock>TABLE1(:, ncols+1) = TABLE2(TABLE3(:nlines-10, 1), ncols-4)</codeblock>
		Die Spaltenüberschriften können ähnlich gelesen und bearbeitet werden: <code>TABLE(#,SPALTE)</code> bzw. <code>TABLE(#,SPALTE) = KOPF</code>
		<h>Kommandos in Zusammenhang mit Tabellen</h>
		In Zusammenhang mit Tabellen sind spezielle Kommandos verfügbar:
		<list>
			<item node="new TABLE1(), TABLE2(), ...">Die Tabellen <code>TABLE1(), TABLE2(), ...</code> erzeugen</item>
			<item node="clear TABLE()">Inhalt der Tabelle <code>TABLE()</code> löschen</item>
			<item node="clear -memory">Alle Tabellen und die automatische Sicherung löschen</item>
			<item node="show TABLE()">Daten aus der entsprechenden Tabelle anzeigen</item>
			<item node="showf TABLE()">Vollständigen Datensatz anzeigen (hat nur Einfluss, wenn kein externer Viewer verwendet wird)</item>
			<item node="rename TABLE(), NEUERNAME()">Die Tabelle <code>TABLE</code> zu <code>NEUERNAME</code> umbenennen. Dies kann nicht auf <code>table</code> angewendet werden!</item>
			<item node="swap TABLE1(), TABLE2()">Den Inhalt der Tabelle <code>TABLE1</code> mit dem Inhalt von <code>TABLE2</code> vertauschen</item>
			<item node="save TABLE()">Daten aus der gewählten Tabelle in eine Datei mit automatisch generiertem Namen speichern. Mit <code>save TABLE() -set filename=NAME</code> kann der Dateiname angegeben werden. Dateinamen mit Leerzeichen müssen von Anführungszeichen umschlossen sein</item>
			<item node="export TABLE()">Daten aus der gewählten Tabelle in eine Textdatei mit automatisch generiertem Dateinamen exportieren. Mit <code>export TABLE() -set filename=NAME</code> kann der Dateiname angegeben werden. Dateinamen mit Leerzeichen müssen ebenfalls von Anführungszeichen umschlossen sein. (Mit der Endung *.tex wird eine TeX-Datei, mit *.csv eine CSV-Datei und mit *.xls wird eine Excel(R)-Mappe erzeugt)</item>
			<item node="delete TABLE(i1:i2,j1:j2)">Alle Einträge von Zeile <expr>i1</expr> bis <expr>i2</expr> und von Spalte <expr>j1</expr> bis <expr>j2</expr> werden unwiderruflich gelöscht. Dabei kann natürlich auch nur ein einziges Element ausgewählt werden</item>
			<item node="remove TABLE1(), TABLE2(), ...">Entfernt die Tabellen <code>TABLE1(), TABLE2(), ...</code> komplett</item>
		</list>
		An <code>clear</code> und <code>delete</code> kann <code>-ignore</code> angehängt werden, um die erforderliche Bestätigung zu unterdrücken.
		<h>Methoden für die Arbeit mit Tabellen</h>
		Tabellen bieten dem Benutzer einige Methoden, die die Arbeit erleichtern und den Code lesbarer machen sollen. Methoden werden mit der Syntax <codeblock>TABLE().METHOD</codeblock> aufgerufen. Die meisten Methoden können dabei noch durch ein oder mehrere Modifizierer verfeinert werden:<codeblock>TABLE().METHOD.MODIFIER1.MODIFIER2</codeblock>Methoden sind <code>avg</code>, <code>std</code>, <code>sum</code>, <code>prd</code>, <code>med</code>, <code>min</code>, <code>max</code>, <code>num</code>, <code>cnt</code> und <code>norm</code>. Sie entsprechen den gleichnamigen Standardfunktionen und werden auf alle Elemente der gewählten Tabelle ausgeführt. Die folgenden Methoden sind zusätzlich definiert:
		<list>
			<item node="TABLE().name">Gibt die Bezeichnung der Tabelle als String zurück, was Konstrukte wie <code>to_string(TABLE())</code> verkürzt</item>
			<item node="TABLE().size">Gibt die Größe der Tabelle in Zeilen und Spalten zurück</item>
			<item node="TABLE().aliasof(sTable)">Wandelt die aktuelle Tabelle in einen Alias der Tabelle um, deren Name als Zeichenkette <code>sTable</code> übergeben wurde. Die aktuelle Tabelle wird dabei maskiert, so dass währenddessen nicht mehr auf sie zugegriffen werden kann. Wird eine leere Zeichenkette übergeben, wird die Dereferenzierung aufgehoben und der Bezug auf die aktuelle Tabelle wiederhergestellt. Der Name der referenzierten Tabelle wird als Zeichenkette zurückgegeben</item>
			<item node="TABLE().minpos">Bestimmt die Position des Minimums der Tabelle und gibt die in Zeilen und Spalten zurück. Im Fall eines mehrfachen Auftretens desselben Wertes, wird nur die zuerst gefundene Position zurückgegeben</item>
			<item node="TABLE().maxpos">Bestimmt die Position des Maximums der Tabelle und gibt die in Zeilen und Spalten zurück. Im Fall eines mehrfachen Auftretens desselben Wertes, wird nur die zuerst gefundene Position zurückgegeben</item>
		</list>
		Als Modifizierer sind die folgenden definiert:
		<list>
			<item node=".lines">Wendet die entsprechende Methode zeilenweise an und gibt eine entsprechende Anzahl an Ergebnissen zurück</item>
			<item node=".cols">Wendet die entsprechende Methode spaltenweise an und gibt eine entsprechende Anzahl an Ergebnissen zurück</item>
			<item node=".grid">Deklariert die aktuelle Tabelle als Datengitter, so dass die ersten beiden Spalten für die Berechnung ignoriert werden</item>
			<item node=".every(nFirst,nIncr)">Ermöglicht es mit <code>lines</code> oder <code>cols</code>, die erste Spalte/Zeile (nFirst) und das Inkrement (jede => nIncr=1, jede zweite => nIncr=2, etc.) vorzugeben. Wird nur ein Wert vorgegeben, so wird dieser für beide Werte verwendet. Spalten/Zeilen können auch gezielt ausgewählt werden, wenn ein Vektor für nFirst (<code>.every({1:10})</code>) übergeben wird</item>
		</list>
		<example desc="Daten in der Tabelle 'table()' anzeigen, anschließendes aufsteigendes Sortieren der Spalten 3-6 nach Spalte 1 und Berechnung der Summe jeder zweiten Spalte:">
			show table()
			[...]
			sort table() cols=1[3:6]
			table().sum.cols.every(2,2)
		</example>
		<em>Siehe auch:</em> <a href="nhlp://new?frame=self">help new</a>, <a href="nhlp://remove?frame=self">help remove</a>, <a href="nhlp://datagrid?frame=self">help datagrid</a>, <a href="nhlp://save?frame=self">help save</a>, <a href="nhlp://string?frame=self">help string</a>, <a href="nhlp://cluster?frame=self">help cluster</a> und <a href="nhlp://delete?frame=self">help delete</a>
	</contents>
</article>