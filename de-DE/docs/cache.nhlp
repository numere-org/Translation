<!--
	NumeRe: Framework fuer Numerische Rechnungen
	Copyright (C) 2016  Erik Haenel et al.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<article id="cache">
	<title string="Tabellen (Caches)" idxkey="cache, table"/>
	<keywords>
		<keyword>cache</keyword>
		<keyword>table</keyword>
		<keyword>tabell</keyword>
		<keyword>rename</keyword>
		<keyword>swap</keyword>
		<keyword>desc</keyword>
		<keyword>lines</keyword>
		<keyword>nlines</keyword>
		<keyword>rows</keyword>
		<keyword>nrows</keyword>
		<keyword>cols</keyword>
		<keyword>ncols</keyword>
		<keyword>every</keyword>
		<keyword>range</keyword>
	</keywords>
	<contents>
		<syntax>
			{VAL} = TABLE(i1:i2,j1:j2)
			{VAL} = TABLE({START:SCHRITTWEITE:ENDE},:)
			TABLE(i1:i2,j1:j2) = {VAL}\n
			{STR} = TABLE(#,j1:j2)
			TABLE(#,j1:j2) = {STR}\n
			new TABLE(), ...
			remove TABLE(), ...\n
			clear TABLE()
			delete TABLE()\n
			show TABLE()\n
			save TABLE()
			save TABLE() -set file=NAME\n
			export TABLE()
			export TABLE() -set file=NAME\n
			rename TABLE(), NEWNAME()\n
			swap TABLE1(), TABLE2()
		</syntax>
		Tabellen sind aktive Speicher in NumeRe, die tabellare Daten zwischenspeichern können, damit selbige weiterverarbeitet werden können. Tabellarische Daten zeichnen sich dadurch aus, dass die Daten spaltenweise organisiert sind. Spalten in NumeRe-Tabellen können entweder numerische Werte, Zeit-Datumswerte, logische Werte, Kategorien oder <a href="nhlp://string?frame=new">Zeichenketten</a> enthalten. Werden numerische Werte in Zeichenketten-Spalten geschrieben, werden sie automatisch in Zeichenketten konvertiert. Schreiben von Zeichenketten in numerische Spalten ist dagegen <em>nur</em> möglich, wenn die Zeichenketten numerisch interpretiert werden können.
		Zeit-Datumswerte werden in Sekunden seit dem 1.1.1970 (UTC) mit Mikrosekunden-Präzision gespeichert. Derartige Werte werden von speziellen Funktionen (wie z.B. <code>time()</code> oder <code>timeformat()</code>) generiert und verarbeitet. Zeit-Datumswerte können auch als Zeichenketten in die entsprechenden Spalten geschrieben werden, wenn sie einem der folgenden Schemata oder einer Datums-Zeitkombination davon entsprechen:
		<verbatim>
			DD.MM.YY(YY)
			YY(YY)-MM-DD
			YY(YY)/MM/DD
			DD/MM/YYYY bzw. D/M/YY(YY)
			hh:mm
			hh:mm:ss
			hh:mm:ss.iii
		</verbatim>
		Standardmäßig existiert die Tabelle <code>table()</code>. Mit dem Kommando <code>new</code> können aber weitere Tabellen mit anderen Namen erzeugt werden:<codeblock>new TABLE1(), TABLE2(), ...</codeblock>
		Einzelne Elemente einer Tabelle können mit der Syntax <code>TABLE(ZEILE, SPALTE)</code> ausgelesen werden. Ebenso können damit auch Werte in die Tabelle geschrieben werden. Dabei sind Tabellen wie gewöhnliche Variablen zu behandeln. Die Indizierung erfolgt dabei durch natürliche Zahlen <em>größer</em> Null: 1,2,3,...
		Bereiche von Elementen können dabei mit der Syntax <code>ERSTER INDEX:ZWEITER INDEX</code> erhalten werden. Wird dabei einer der beiden Indices weggelassen, wird er automatisch durch den minimalen bzw. maximalen Index ergänzt. Fehlen beide Indices, wird folglich der gesamte, mögliche Bereich ausgewählt. Es können auch Zeilen/Spalten aus anderen Tabellen oder Datenfiles als Indexmenge verwendet werden.
		Zusätzlich kann mittels <a href="nhlp://operator?frame=new"><code>{START:SCHRITTWEITE:ENDE}</code></a> die Schrittweite der Indizes vorgegeben werden.
		Wird eine gesamte Spalte in der Form <code>TABLE(:,j) = VALUES</code> überschrieben, so kann dabei auch der Typ der Spalte <code>j</code> von numerisch zu Zeichenkette oder umgekehrt geändert werden. Die Spaltenüberschrift bleibt dabei erhalten; eventuell vorher in der Spalten <code>j</code> enthaltene Daten werden <em>komplett</em> entfernt.
		Beim Zugriff auf eine Tabelle enthalten die speziellen Variablen <code>nrows</code> die Zahl der Zeilen und <code>ncols</code> die Zahl der Spalten der aktuellen Tabelle, wenn sie in dessen Argumentklammern verwendet werden (<code>nlines</code> ist ein Alias). Das gilt auch, wenn weitere Datenobjekte im Ausdruck oder als Indexmenge verwendet werden:<codeblock>TABLE1(:, ncols+1) = TABLE2(TABLE3(:nrows-10, 1), ncols-4)</codeblock>
		Die Spaltenüberschriften können ähnlich gelesen und bearbeitet werden: <code>TABLE(#,SPALTE)</code> bzw. <code>TABLE(#,SPALTE) = KOPF</code>
		<h>Kommandos in Zusammenhang mit Tabellen</h>
		In Zusammenhang mit Tabellen sind spezielle Kommandos verfügbar:
		<list>
			<item node="new TABLE1(), TABLE2(), ...">Die Tabellen <code>TABLE1(), TABLE2(), ...</code> erzeugen</item>
			<item node="clear TABLE()">Inhalt der Tabelle <code>TABLE()</code> löschen</item>
			<item node="clear -memory">Alle Tabellen und die automatische Sicherung löschen</item>
			<item node="show TABLE()">Daten aus der entsprechenden Tabelle anzeigen</item>
			<item node="showf TABLE()">Vollständigen Datensatz anzeigen (hat nur Einfluss, wenn kein externer Viewer verwendet wird)</item>
			<item node="rename TABLE(), NEUERNAME()">Die Tabelle <code>TABLE</code> zu <code>NEUERNAME</code> umbenennen. Dies kann nicht auf <code>table</code> angewendet werden!</item>
			<item node="swap TABLE1(), TABLE2()">Den Inhalt der Tabelle <code>TABLE1</code> mit dem Inhalt von <code>TABLE2</code> vertauschen</item>
			<item node="save TABLE()">Daten aus der gewählten Tabelle in eine Datei mit automatisch generiertem Namen speichern. Mit <code>save TABLE() -set filename=NAME</code> kann der Dateiname angegeben werden. Dateinamen mit Leerzeichen müssen von Anführungszeichen umschlossen sein</item>
			<item node="export TABLE()">Daten aus der gewählten Tabelle in eine Textdatei mit automatisch generiertem Dateinamen exportieren. Mit <code>export TABLE() -set filename=NAME</code> kann der Dateiname angegeben werden. Dateinamen mit Leerzeichen müssen ebenfalls von Anführungszeichen umschlossen sein. (Mit der Endung *.tex wird eine TeX-Datei, mit *.csv eine CSV-Datei und mit *.xls wird eine Excel(R)-Mappe erzeugt)</item>
			<item node="delete TABLE(i1:i2,j1:j2)">Alle Einträge von Zeile <expr>i1</expr> bis <expr>i2</expr> und von Spalte <expr>j1</expr> bis <expr>j2</expr> werden unwiderruflich gelöscht. Dabei kann natürlich auch nur ein einziges Element ausgewählt werden</item>
			<item node="remove TABLE1(), TABLE2(), ...">Entfernt die Tabellen <code>TABLE1(), TABLE2(), ...</code> komplett</item>
		</list>
		An <code>clear</code> und <code>delete</code> kann <code>-ignore</code> angehängt werden, um die erforderliche Bestätigung zu unterdrücken.
		<h>Methoden für die Arbeit mit Tabellen</h>
		Tabellen bieten dem Benutzer einige Methoden, die die Arbeit erleichtern und den Code lesbarer machen sollen. Methoden werden mit der Syntax <codeblock>TABLE().METHOD</codeblock> aufgerufen. Die meisten Methoden können dabei noch durch ein oder mehrere Modifizierer verfeinert werden:<codeblock>TABLE().METHOD.MODIFIER1.MODIFIER2</codeblock>Methoden sind <code>avg</code>, <code>std</code>, <code>sum</code>, <code>prd</code>, <code>med</code>, <code>min</code>, <code>max</code>, <code>num</code>, <code>cnt</code> und <code>norm</code>. Sie entsprechen den gleichnamigen Standardfunktionen und werden auf alle Elemente der gewählten Tabelle ausgeführt. Die folgenden Methoden sind zusätzlich definiert:
		<list>
			<item node="TABLE().name">Gibt die Bezeichnung der Tabelle als String zurück, was Konstrukte wie <code>to_string(TABLE())</code> verkürzt</item>
			<item node="TABLE().description">Gibt die Beschreibung der Tabelle bzw. des Datensatzes als String zurück</item>
			<item node="TABLE().describe(sDesc)">Aktualisiert die Beschreibung der Tabelle oder des Datensatzes zu dem Inhalt von <code>sDesc</code>. Die Beschreibung kann genutzt werden, den Inhalt des Datensatzes in Worten zu beschreiben, indem die Quelle und die Erhebungsmethode dokumentiert wird</item>
			<item node="TABLE().size">Gibt die Größe der Tabelle in Zeilen und Spalten zurück</item>
			<item node="TABLE().rows">Gibt die Zahl der Zeilen der Tabelle zurück</item>
			<item node="TABLE().cols">Gibt die Zahl der Spalten der Tabelle zurück</item>
			<item node="TABLE().aliasof(sTable)">Wandelt die aktuelle Tabelle in einen Alias der Tabelle um, deren Name als Zeichenkette <code>sTable</code> übergeben wurde. Die aktuelle Tabelle wird dabei maskiert, so dass währenddessen nicht mehr auf sie zugegriffen werden kann. Wird eine leere Zeichenkette übergeben, wird die Dereferenzierung aufgehoben und der Bezug auf die aktuelle Tabelle wiederhergestellt. Der Name der referenzierten Tabelle wird als Zeichenkette zurückgegeben</item>
			<item node="TABLE().categorize({nCols},{sCategories})">Aktualisiert die Kategorien einer kategorialen Spalte (konvertiert sie sofern nötig). Die Zahl der neuen Kategorien muss dabei nicht mit den bisherigen Kategorien übereinstimmen. Bei Erfolg werden die neuen Kategorien der ausgewählten kategorialen Spalte(n) als Schlüssel-Wert-Liste zurückgegeben</item>
			<item node="TABLE().categoriesof({nCols})">Gibt die Kategorien der ausgewählten kategorialen Spalte(n) als Schlüssel-Wert-Liste zurück. Sind die ausgewählten Spalten nicht kategorial, wird eine leere Zeichenkette zurückgegeben</item>
			<item node="TABLE().convert({nCols},sType)">Wandelt den Spaltentyp der mit <code>{nCols}</code> indizierten Spalten in den Typ <code>sType</code> um. Der neue Typ kann dabei entweder als <code>"value"</code>, <code>"string"</code>, <code>"datetime"</code>, <code>"logical"</code> oder <code>"category"</code> angegeben werden. <code>"auto"</code> führt eine automatische Detektion der besten Konvertierung je Spalte aus. Ist die Konvertierung erfolgreich, wird der neue Typ als Zeichenkette zurückgegeben, anderenfalls ist die Zeichenkette leer. <code>"auto"</code> ist immer erfolgreich, auch wenn keine Spalte konvertiert wurde. Eine Konvertierung ist nur möglich, wenn die in der jeweiligen Spalte verwendeten Daten auch in dem neuen Typ interpretierbar sind</item>
			<item node="TABLE().typeof({nCols})">Gibt den Spaltentyp der mit <code>{nCols}</code> indizierten Spalten als Zeichenketten zurück. Der Typ kann dabei entweder als <code>"value"</code>, <code>"string"</code>, <code>"datetime"</code>, <code>"logical"</code> oder <code>"category"</code> angegeben werden. Leere oder nicht vorhandene Spalten haben den Typ <code>"none"</code></item>
			<item node="TABLE().minpos">Bestimmt die Position des Minimums der Tabelle und gibt diese in Zeilen und Spalten zurück. Im Fall eines mehrfachen Auftretens desselben Wertes, wird nur die zuerst gefundene Position zurückgegeben</item>
			<item node="TABLE().maxpos">Bestimmt die Position des Maximums der Tabelle und gibt diese in Zeilen und Spalten zurück. Im Fall eines mehrfachen Auftretens desselben Wertes, wird nur die zuerst gefundene Position zurückgegeben</item>
			<item node="TABLE().indexof(nCol,vals{})">Gibt die Indices der Elemente in der Spalte <code>nCol</code> zurück, die mit den Werte im Cluster <code>vals{}</code> übereinstimmen. Jeder Satz von Indices ist durch ein NaN von den anderen Sätzen getrennt</item>
			<item node="TABLE().fndcols({sNames})">Gibt die Indices aller Spalten zurück, deren Überschriften mit <code>sNames</code> übereinstimmen. Wird nichts gefunden, wird NaN zurückgegeben</item>
			<item node="TABLE().countif({nCols},vals{})">Zählt die Elemente in den Spalten <code>nCols</code>, die mit den Werten im Cluster <code>vals{}</code> übereinstimmen. Für jede Spalte und jeden Wert in <code>vals{}</code> wird eine Summe geordnet nach den Spalten zurück gegeben</item>
			<item node="TABLE().binsof(nCol,nBins)">Berechnet ein einfaches Histogramm der Daten in der Spalte <code>nCol</code>. Wenn die Zahl der Bins <code>nBins</code> nicht vorgegeben wird, wird diese mithilfe der Sturges-Regel bestimmt. Ist die Spalte kategorial, dann werden die Kategorien als Bins verwendet. Bei logischen Spalten werden die logischen Werte als Bins verwendet</item>
			<item node="TABLE().covarof(nCol1,nCol2,nRows1,nRows2)">Berechnet die Kovarianz der Spalten <code>nCol1</code> und <code>nCol2</code>. Die jeweiligen Zeilen können vorgegeben werden und entsprechen standardmäßig der vollen Dimension</item>
			<item node="TABLE().pcorrof(nCol1,nCol2,nRows1,nRows2)">Berechnet die <em>Pearson</em>-Korrelation der Spalten <code>nCol1</code> und <code>nCol2</code>. Die jeweiligen Zeilen können vorgegeben werden und entsprechen standardmäßig der vollen Dimension. Die Pearson-Korrelation kann nur aus numerischen Werten berechnet werden</item>
			<item node="TABLE().scorrof(nCol1,nCol2,nRows1,nRows2)">Berechnet die <em>Spearman</em>-Korrelation der Spalten <code>nCol1</code> und <code>nCol2</code>. Die jeweiligen Zeilen können vorgegeben werden und entsprechen standardmäßig der vollen Dimension. Die Spearman-Korrelation kann von allen Variablentypen berechnet werden. Bei der Berechnung der zugehörigen Ränge wird Groß- und Kleinschreibung berücksichtigt</item>
			<item node="TABLE().rankof(nCol,cType,nRows)">Berechnet die Ränge der Werte in der Spalte <code>nCol</code> for die Zeilen <code>nRows</code> gemäß des Typs <code>cType</code>. Die Zeilen können vorgegeben werden und entsprechen standardmäßig der vollen Dimension. Der Typ <code>cType</code> gibt vor, wie die Ränge vergeben werden. <code>cType = "c"</code>: kompetetiv, d.h. nach dem <em>1-2-2-4-Schema</em>, <code>cType = "f"</code>: fraktioniert, d.h. nach dem <em>1-2.5-2.5-4-Schema</em>, <code>cType = "d"</code>: konsekutiv-dicht, d.h. nach dem <em>1-2-2-3-Schema</em></item>
			<item node="TABLE().zscoreof(nCol,nRows)">Berechnet die Standardisierung der Werte bezogen auf ihre Abweichung vom Mittelwert (auch z-Score genannt) in der Spalte <code>nCol</code> für die Zeilen <code>nRows</code>. Die Zeilen können vorgegeben werden und entsprechen standardmäßig der vollen Dimension. Mittelwert und Standardabweichung werden stets bezogen auf die ausgewählten Zeilen berechnet</item>
			<item node="TABLE().anovaof(nCategy,nCol,fSignif,nRows)">Führt eine Varianzanalyse (ANOVA) für die Kategorien der Spalte <code>nCategs</code> und die Werte der Spalte <code>nCol</code> unter Verwendung des Signifikanzwertes <code>fSignif</code> für die Zeilen <code>nRows</code> durch. Die Zeilen können vorgegeben werden und entsprechen standardmäßig der vollen Dimension. Es wird eine Schlüssel-Wert-Liste mit den berechneten relevanten Werten zurückgegeben</item>
		</list>
		Als Modifizierer sind die folgenden definiert:
		<list>
			<item node=".rows">Wendet in Kombination mit einer weiteren Methode diese zeilenweise an und gibt eine entsprechende Anzahl an Ergebnissen zurück (<code>.lines</code> ist ein Alias)</item>
			<item node=".cols">Wendet in Kombination mit einer weiteren Methode diese spaltenweise an und gibt eine entsprechende Anzahl an Ergebnissen zurück</item>
			<item node=".grid">Deklariert die aktuelle Tabelle als Datengitter, so dass die ersten beiden Spalten für die Berechnung ignoriert werden</item>
			<item node=".every(nFirst,nIncr)">Ermöglicht es mit <code>rows</code> oder <code>cols</code>, die erste Spalte/Zeile (nFirst) und das Inkrement (jede => nIncr=1, jede zweite => nIncr=2, etc.) vorzugeben. Wird nur ein Wert vorgegeben, so wird dieser für beide Werte verwendet. Spalten/Zeilen können auch gezielt ausgewählt werden, wenn ein Vektor für nFirst (<code>.every({1:10})</code>) übergeben wird</item>
		</list>
		<example desc="Daten in der Tabelle 'table()' anzeigen, anschließendes aufsteigendes Sortieren der Spalten 3-6 nach Spalte 1 und Berechnung der Summe jeder zweiten Spalte:">
			show table()
			[...]
			sort table() cols=1[3:6]
			[...]
			table().sum.cols.every(2,2)
		</example>
		<em>Siehe auch:</em> <a href="nhlp://new?frame=self">help new</a>, <a href="nhlp://remove?frame=self">help remove</a>, <a href="nhlp://datagrid?frame=self">help datagrid</a>, <a href="nhlp://save?frame=self">help save</a>, <a href="nhlp://string?frame=self">help string</a>, <a href="nhlp://cluster?frame=self">help cluster</a> und <a href="nhlp://delete?frame=self">help delete</a>
	</contents>
</article>