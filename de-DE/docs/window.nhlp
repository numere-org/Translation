<!--
	NumeRe: Framework fuer Numerische Rechnungen
	Copyright (C) 2021  Erik Haenel et al.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<article id="window">
	<title string="Graphische Benutzeroberflächen" />
	NumeRe ist zur Erzeugung von und Interaktion mit graphischen Benutzeroberflächen in der Lage, mit denen sich auch anspruchsvolle Applikationen (oder Prototypen) mit vergleichsweise geringem Aufwand entwickeln lassen können. Das zentrale Kommando hierfür ist <code>window</code> in der Form<codeblock>RES = window EX [-PAR]</codeblock>Dabei unterscheiden sich die Rückgabewerte <code>RES</code> des Kommandos in Abhängigkeit vom verwendeten Ausdruck <code>EX</code> und den Parametern <code>PAR</code>. Zur Erzeugung eines neuen Fensters kann die Form<codeblock>ID = window LAYOUTSCIPT</codeblock>verwendet werden. Sie gibt dabei die ID des aus dem Layout-Script (siehe späterer Abschnitt) neu erzeugten Fensters zurück. Mit dieser ID kann später mit diesem Fenster interagiert und programmatisch Eigenschaften verändet werden (die Parameter werden im folgenden Abschnitt noch genauer beschrieben):<codeblock>ITEMIDS = window ID -getitems=TYPE\nVAL = window ID -get PROP\nLOG = window ID -set PROP=VAL\nLOG = window ID -close</codeblock>
	<h>Parameter für dieses Kommando</h>
	<list>
		<item node="set PROP=VAL">Der Parameter <code>set</code> wird verwendet, um die Eigenschaften <code>PROP</code> in einem bereits geöffneten Fenster zu modifizieren. Die Eigenschaften <code>value</code>, <code>label</code>, <code>color</code> und <code>state</code> können dabei modifiziert werden. Diese werden in einem späteren Abschnitt noch genauer definiert. Der Rückgabewert des Kommandos ist in diesem Fall ein logisches <code>true</code> oder <code>false</code>, das indiziert, ob die Modifikation erfolgreich war</item>
		<item node="get PROP">Der Parameter <code>get</code> wird verwendet, um die Werte der Eigenschaften <code>PROP</code> aus einem bereits geöffneten Fenster zu lesen. Die Eigenschaften <code>value</code>, <code>label</code>, <code>color</code> und <code>state</code> können dabei gelesen werden.</item>
		<item node="item=ID">Mit dieser Option lässt sich ein einzelnes Element des Fensters auswählen, anderenfalls werden die Eigenschaften des Fensters selbst verwendet. <em>Hinweis:</em> Es kann sein, dass manche Elemente nicht alle Eigenschaften besitzen</item>
		<item node="getitems=TYPE">Mit diesem Parameter können die ITEMIDS aller Elemente in einem Fenster, die einem spezifischen Typ <code>TYPE</code> entsprechen, gelesen werden. Für <code>TYPE</code> können die Kommandos der Layout-Scripte verwendet werden (außer <code>layout</code> und <code>group</code>).</item>
		<item node="close">Mit diesem Parameter wird das entsprechende Fenster geschlossen. Der Rückgabewert ist ein logischer Wert, der den Erfolg indiziert. <em>Hinweis:</em> der <a href="nhlp://close?frame=new">Kommandoausdruck</a> <code>close -all</code> wird auch alle Fenster schließen, die mit <code>window</code> erzeugt wurden.</item>
	</list>
	<h>Layout-Scripte</h>
	Ein zentrales Element in der Erzeugung einer graphischen Oberfläche sind Layout-Scripte. Das sind Dateien, welche die Dateierweitung <em>*.nlyt</em> verwenden. Sie werden standardmäßig im <code>&lt;scriptpath&gt;</code> erwartet, können aber auch durch eine explizite Pfadangabe aus einem anderen Ordner geladen werden.
	In einem Layout-Script kann eine <em>sehr eingeschränkte</em> NumeRe-Syntax verwendet werden: Kommentare durch <code>##</code> und <code>#* ... *#</code> werden vollständig unterstützt. Kontrollflusselemente wie <code>for ... endfor</code> und <code>if ... else ... endif</code> werden dagegen nicht unterstützt. Hinzu kommt noch, dass nur Code verwendet wird, der sich im ersten <code>layout ... endlayout</code>-Block der Datei befindet und nur Kommandoausdrücke der folgenden Liste verwendbar sind. Davon getrennte Ausdrücke sind nicht möglich.
	Ein Layout-Script setzt sich aus den folgenden Kommandoausdrücken zusammen:
	<list>
		<item node="layout [-PAR]<br>    ...<br>endlayout">Dieser Block umschließt alle anderen GUI-Elemente und definiert das Fenster selbst. Über die Parameter können die Hintergrundfarbe (<code>color={R,G,B}</code>), Fenstertitel (<code>title=TITLE</code>), Fenster-Icon (<code>icon=PATH/TO/ICON.ico</code>) und Fenstergröße (<code>size={x,y}</code>) modifiziert werden.</item>
		<item node="group [-PAR]<br>    ...<br>endgroup">Mit diesen Blöcken können weitere GUI-Elemente zusammengefasst werden (auch weitere <code>group ... endgroup</code>-Blöcke) und die Orientierung der Elementanordnung angepasst werden (<code>type=ORIENT</code>). Wird ein zusätzliches <code>label=NAME</code> verwendet, wird die Gruppe in eine zusätzliche Box eingebettet, die entsprechend beschriftet ist. Gruppen haben dazu auch Einfluss auf das Skalierungsverhalten der einzelnen GUI-Elemente und schränken dies auf ihre Ausrichtung ein. Mit der Option <code>expand</code> kann dieses Verhalten deaktiviert werden, so dass in <expr>x</expr>- und <expr>y</expr>-Richtung skaliert wird.</item>
		<item node="button EX [-set PAR]">Erzeugt eine klickbare Schaltfläche, die mit <code>EX</code> beschriftet ist.</item>
		<item node="radio EX [-set PAR]">Erzeugt eine Radio-Gruppe, deren Werte aus <code>EX</code> in Form einer Liste von Zeichenketten entnommen werden.</item>
		<item node="text EX [-set PAR]">Stellt den Text aus <code>EX</code> ohne weitere GUI-Elemente dar.</item>
		<item node="textfield EX [-set PAR]">Generiert eine Texteingabezeile mit dem Standardwert <code>EX</code>.</item>
		<item node="treelist [-set PAR]">Generiert eine Treelist, die zusätzlich mit Checkboxen ausgestattet sein kann. Die Zahl der Spalten und Elemente kann durch <code>size={row, col}</code> oder direkt durch die Angabe von Werten mittels <code>label={LABEL1, ...}</code> und <code>value={VAL1, ...}</code> vorgegeben werden. <code>value={VAL1, ...}</code> gibt die Elemente Zeilenweise vor, wobei die Zeilen durch Tabulatoren (<code>\t</code>) getrennt sein müssen (z.B.: <code>value={"COL1\tCOL2\tCOL3\t...", "...}</code>). Werden zusätzliche Checkboxen verwendet, so definiert der erste Wert (<code>1</code> oder <code>0</code>) den Status dieser Checkboxen (z.B.: <code>value={"1\tCOL1\t...", "0\t...}</code>).</item>
		<item node="checkbox EX [-set PAR]">Generiert eine klickbare Checkbox, die mit <code>EX</code> beschriftet ist.</item>
		<item node="dropdown EX [-set PAR]">Generiert eine Dropdown-Liste, deren Werte aus <code>EX</code> in Form einer Liste von Zeichenketten entnommen werden.</item>
		<item node="spinbut [-set PAR]">Generiert einen Spinbutton, der mit <code>EX</code> beschriftet ist. Minimaler (<code>min=VAL</code>) und maximaler (<code>max=VAL</code>) sind konfigurierbar</item>
		<item node="gauge [-set PAR]">Erzeugt einen Fortschrittsbalken, der entweder horizontal oder vertikal orientiert sein kann.</item>
		<item node="tablegrid [-set PAR]">Erzeugt ein Tabellengitter mit einer definierten Anzahl an Zeilen und Spalten (<code>size={row, col}</code>), jedoch mindestens einer Zeile und einer Spalte. Werte der Tabelle können durch <code>window ID -set value=TABLEDATA() item=ITEMID</code> verändert und durch <code>window ID -get value item=ITEMID target=TARGETTABLE()</code> gelesen werden. Bei Fehlen der <code>target=TARGETTABLE()</code>-Option wird <code>valtable()</code> als Standard verwendet.</item>
		<item node="image EX [-set PAR]">Zeigt das Bild aus der Datei <code>EX</code> an.</item>
		<item node="grapher [-set PAR]">Generiert ein Graph-Objekt mit konfigurierbarer Größe (<code>size={x,y}</code>, standardmäßig <expr>640times480</expr>). Das Graph-Objekt kann nur durch ein Plotting-Kommando, das die <code>streamto={WINID,ITEMID}</code>-Option verwendet, befüllt werden.</item>
	</list>
	Damit hat ein Layout-Script die folgende generische Gestalt:
	<codeblock>
	layout [-PAR]
	\tGUI-ELEMENTE ODER group ... endgroup
	endlayout
	</codeblock>
	<h>Eigenschafts-Optionen für die Kommandos in Layout-Scripten</h>
	Die GUI-Elemente der oberen Liste können durch die folgenden Eigenschafts-Optionen weiter modifiziert werden. Dabei unterstützen nicht alle Kommandos dieselben Eigenschafts-Optionen.
	<list>
		<item node="size={x,y}">Einstellen der Größe des Fensters, des Graph-Objekts (beides in Pixel) und des Tabellengitters (in Zeilen und Spalten).</item>
		<item node="color={R,G,B}">Vorder- (<code>button</code> und <code>text</code>) oder Hintergrundfarbe (alle anderen außer <code>grapher</code> und <code>tablegrid</code>) eines GUI-Elements anpassen. Die RGB-Werte sind pro Kanal im Intervall [0,255] anzugeben.</item>
		<item node="id=ID">Einstellen einer selbst definierten ITEMID eines GUI-Elements. Der ITEMID-Bereich [0,999] ist für den Benutzer reserviert. GUI-Elemente ohne diese Option haben eine ITEMID größer oder gleich 1000. Diese ITEMIDs müssen dabei nicht aufeinanderfolgend sein.</item>
		<item node="value=VAL">Definiert den Standardwert (bei Verwendung im Layout-Script) oder kann verwendet werden, um den aktuellen Wert eines GUI-Elements zu lesen oder zu modifizieren. Das Kommando <code>treelist</code> kann hierbei eine Liste von Werte in Form eines Vektors aufnehmen. <em>Hinweis:</em> der Wert des Fensters selbst ist seine Größe (bei Verwendung in z.B. <code>window ID -get value</code> ohne <code>item=ITEMID</code>).</item>
		<item node="type=TYPE">Definiert die Orientierung des GUI-Elements (<code>type=vertical</code> und <code>type=horizontal</code>) bei <code>group ... endgroup</code>, <code>radio</code> und <code>gauge</code>. Kann auch verwendet werden, um ein <code>textfield</code> über <code>type=multiline</code> mehrzeilig zu machen, oder mittels <code>type=checkmark</code> bei <code>treelist</code> zusätzliche Checkboxen zu aktivieren.</item>
		<item node="label=NAME">Viele GUI-Elemente können mit dieser Option zusätzlich beschriftet werden. Für <code>button</code> ist <code>value</code> und <code>label</code> identisch. Beim Kommando <code>treelist</code> definiert diese Option die Namen der Spalten und kann mehrere Werte in Form eines Vektors übergeben bekommen.</item>
		<item node="state=STATE">Mit dieser Option können GUI-Elemente programmatisch aktiviert (<code>state=enabled</code>), deaktiviert (<code>state=disabled</code>) und ausgeblendet (<code>state=hidden</code>) werden. Elemente sind standardmäßig aktiviert. Ausgeblendete Elemente benötigen trotzdem ihren Platz im Fenster.</item>
		<item node="onclick=EVENT">Definiert den Event-Handler, der beim Klicken auf <code>button</code>, eine Zelle in einem <code>tablegrid</code>, eines Elements in <code>treelist</code> und einer Position in <code>grapher</code> verwendet werden soll (siehe unten für Details).</item>
		<item node="onchange=EVENT">Definiert den Event-Handler, der beim Ändern eines Wertes in einem GUI-Element verwendet werden soll (Details siehe unten).</item>
	</list>
	<h>Events und Event-Handling</h>
	Im Gegensatz zu den einfachen <a href="nhlp://dialog?frame=new">Dialogen</a>, die mit <code>dialog</code> erzeugt werden können und die auf eine Interaktion des Benutzers warten, bevor eine neue Eingabe in die NumeRe-Konsole möglich ist, sind die graphischen Benutzeroberflächen, die von <code>window</code> erzeugt werden, Event-basiert. Das bedeutet, dass die Konsole weiterhin verwendet werden kann, auch wenn ein Fenster geöffnet ist. Sobald der Benutzer mit diesem interagiert, erzeugt er Events, die verarbeitet werden können.
	Dazu können den GUI-Elementen über die <code>onclick=EVENT</code> und <code>onchange=EVENT</code>-Optionen Event-Handler zugewiesen werden. Diese werden, sobald das entsprechende Event auftritt, aufgerufen und können das Event verarbeiten. Der einfachste Event-Handler ist <code>close</code>, der einfach das Fenster schließt, z.B. in dieser Form:<codeblock>button "Ende" -set onclick=close</codeblock>
	Die Alternative ist die Verwendung von <a href="nhlp://procedure?frame=new">NumeRe-Prozeduren</a>. Diese müssen die folgende Signatur haben<codeblock>procedure $PROC(WINID, ITEMID, EVENT{}) :: event</codeblock>wobei <code>WINID</code> die ID des Fensters, <code>ITEMID</code> die ID des GUI-Elements und <code>EVENT{}</code> eine Schlüssel-Wert-Liste ist (die Funktion <code>getkeyval()</code> vereinfacht die Interaktion), welche die folgenden Informationen enthält:<codeblock>EVENT{} = {"event", "EVENTTYPE", "object", "TYPE", "value", VALUE, "state", "STATE"}</codeblock>Eine Prozedur kann für <em>beliebig viele</em> Events und auch für komplett verschiedene Fenster (sofern das im aktuellen Kontext sinnvoll ist) als Event-Handler eingesetzt werden.
	Im vorherigen Beispiel mit <code>button "Ende" -set onclick=$PROC()</code> (Argumentliste ist unnötig) wären die folgenden Werte enthalten:<codeblock>EVENT{} = {"event", "onclick", "object", "button", "value", "Ende", "state", "enabled"}</codeblock>
	<em>Hinweis:</em> Wenn ein Event-Handler eine längere Rechenzeit hat, hat das keine negativen Auswirkungen auf die graphische Benutzeroberfläche. Sie ist dennoch benutzbar. Allerdings sei darauf hingewiesen, dass der Nutzer natürlich eine Reaktion in einem vernünftigen Zeitrahmen erwartet; zumindest einmal die Information, dass im Moment gerechnet wird.
	<example desc="Ein Window-Layout, das eine interaktive Vorschau des Ergebnisses von <code>smooth</code> mit einem wählbaren Level ermöglicht:" type="verbatim">
		|   ## Window-Layout: Oben ein breites Graph-Objekt, darunter eine Zeile mit Kontrollen
		|   layout -title="Smooth Preview" size={700, 300}
		|       grapher -set id=0 size={600, 200}
		|       group -type=horizontal
		|           textfield #&lt;loadpath&gt; -set id=1
		|           button "Select" -set onclick=$smoothevent()
		|           spinbut -set min=1 max=10 value=3 label="Smoothing level" id=2
		|           button "Smooth!" -set onclick=$smoothevent()
		|       endgroup
		|   endlayout
		|
		|
		|   ## Prozedur, die in der Datei '&PROCPATH&/smoothevent.nprc' zu finden wäre
		|   procedure $smoothevent(_nWinID, _nItemID, _event{}) :: event
		|       str sPath
		|       tab dat()
		|       var nOrder = 1
		|       
		|       sPath = window _nWinID -get value item=1;
		|       clear data() -ignore
		|       
		|       if (getkeyval(_event{}, "value") == "Select")
		|           ## Eine neue Datei über einen Dialog auswählen und plotten
		|           sPath = dialog sPath -set type=filedialog title="Select file";
		|           window _nWinID -set value=sPath item=1;
		|           load sPath;
		|           plot data(:, 1:2) "" -set box streamto={_nWinID, 0} reset aspect=3 connect
		|       else
		|           ## Die vorhandene Datei glätten und zusammen mit dem Original plotten
		|           nOrder = window _nWinID -get value item=2;
		|           load sPath;
		|           copy data(:, 1:2) -target=dat();
		|           smooth dat(:, 2) -order=nOrder
		|           plot data(:, 1:2) "", dat() "" -set box streamto={_nWinID, 0} reset aspect=3 connect
		|       endif
		|       
		|       return void;
		|   endprocedure
	</example>
	<img src="<>/docs/window.png" />
	<em>Siehe auch:</em> <a href="nhlp://plot?frame=self">help plot</a>, <a href="nhlp://dialog?frame=self">help dialog</a> und <a href="nhlp://procedure?frame=self">help procedure</a>
</article>